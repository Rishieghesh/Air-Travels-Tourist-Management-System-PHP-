(function () {
  // Utility class
  class Util {
    extend(custom, defaults) {
      for (let key in custom) {
        if (custom[key] != null) {
          defaults[key] = custom[key];
        }
      }
      return defaults;
    }

    isMobile(userAgent) {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
    }
  }

  // Polyfill WeakMap if not supported
  let WeakMapPolyfill = this.WeakMap || class {
    constructor() {
      this.keys = [];
      this.values = [];
    }

    get(key) {
      for (let i = 0; i < this.keys.length; i++) {
        if (this.keys[i] === key) {
          return this.values[i];
        }
      }
    }

    set(key, value) {
      for (let i = 0; i < this.keys.length; i++) {
        if (this.keys[i] === key) {
          this.values[i] = value;
          return;
        }
      }
      this.keys.push(key);
      this.values.push(value);
    }
  };

  // WOW.js main class
  this.WOW = class {
    constructor(options = {}) {
      this.config = new Util().extend(options, this.defaults);
      this.util = new Util();
      this.animationNameCache = new WeakMapPolyfill();
      this.scrolled = true;

      this.scrollCallback = this.scrollCallback.bind(this);
      this.scrollHandler = this.scrollHandler.bind(this);
      this.start = this.start.bind(this);
    }

    // Default configuration
    defaults = {
      boxClass: "wow",
      animateClass: "animated",
      offset: 0,
      mobile: true,
    };

    // Initialize WOW
    init() {
      this.element = window.document.documentElement;
      const readyState = document.readyState;
      if (readyState === "interactive" || readyState === "complete") {
        this.start();
      } else {
        document.addEventListener("DOMContentLoaded", this.start);
      }
    }

    // Start animating boxes
    start() {
      this.boxes = this.element.getElementsByClassName(this.config.boxClass);
      if (!this.boxes.length || this.disabled()) {
        return this.resetStyle();
      }

      for (let box of this.boxes) {
        this.applyStyle(box, true);
      }

      window.addEventListener("scroll", this.scrollHandler, false);
      window.addEventListener("resize", this.scrollHandler, false);
      this.interval = setInterval(this.scrollCallback, 50);
    }

    // Stop WOW
    stop() {
      window.removeEventListener("scroll", this.scrollHandler, false);
      window.removeEventListener("resize", this.scrollHandler, false);
      if (this.interval != null) {
        clearInterval(this.interval);
      }
    }

    // Show an element with animation
    show(box) {
      this.applyStyle(box);
      box.className += ` ${this.config.animateClass}`;
    }

    // Apply custom style with optional animation data
    applyStyle(box, hidden = false) {
      const duration = box.getAttribute("data-wow-duration");
      const delay = box.getAttribute("data-wow-delay");
      const iteration = box.getAttribute("data-wow-iteration");

      this.animate(() => {
        this.customStyle(box, hidden, duration, delay, iteration);
      });
    }

    // Cross-browser requestAnimationFrame fallback
    animate(callback) {
      if ("requestAnimationFrame" in window) {
        return window.requestAnimationFrame(callback);
      } else {
        return callback();
      }
    }

    // Make all boxes visible without animation
    resetStyle() {
      for (let box of this.boxes) {
        box.setAttribute("style", "visibility: visible;");
      }
    }

    // Add animation styles
    customStyle(box, hidden, duration, delay, iteration) {
      if (hidden) this.cacheAnimationName(box);

      box.style.visibility = hidden ? "hidden" : "visible";

      if (duration) this.vendorSet(box.style, { animationDuration: duration });
      if (delay) this.vendorSet(box.style, { animationDelay: delay });
      if (iteration) this.vendorSet(box.style, { animationIterationCount: iteration });

      this.vendorSet(box.style, {
        animationName: hidden ? "none" : this.cachedAnimationName(box),
      });
    }

    // Add vendor-prefixed styles
    vendors = ["moz", "webkit"];

    vendorSet(style, properties) {
      for (let name in properties) {
        const value = properties[name];
        style[name] = value;
        for (let vendor of this.vendors) {
          style[`${vendor}${name.charAt(0).toUpperCase()}${name.substr(1)}`] = value;
        }
      }
    }

    // Get computed animation name
    animationName(box) {
      let style;
      try {
        style = this.vendorCSS(box, "animation-name").cssText;
      } catch (error) {
        style = window.getComputedStyle(box).getPropertyValue("animation-name");
      }
      return style === "none" ? "" : style;
    }

    // Cache the animation name for performance
    cacheAnimationName(box) {
      this.animationNameCache.set(box, this.animationName(box));
    }

    // Get cached animation name
    cachedAnimationName(box) {
      return this.animationNameCache.get(box);
    }

    // Get vendor-prefixed CSS property
    vendorCSS(box, property) {
      const computed = window.getComputedStyle(box);
      let result = computed.getPropertyCSSValue(property);

      for (let vendor of this.vendors) {
        result = result || computed.getPropertyCSSValue(`-${vendor}-${property}`);
      }

      return result;
    }

    // Scroll handler
    scrollHandler() {
      this.scrolled = true;
    }

    // Callback for checking visibility and triggering animation
    scrollCallback() {
      if (!this.scrolled) return;
      this.scrolled = false;

      this.boxes = Array.from(this.boxes).filter((box) => {
        if (this.isVisible(box)) {
          this.show(box);
          return false; // Remove from boxes list
        }
        return true;
      });

      if (this.boxes.length === 0) this.stop();
    }

    // Get top offset of an element
    offsetTop(element) {
      let top = element.offsetTop;
      while ((element = element.offsetParent)) {
        top += element.offsetTop;
      }
      return top;
    }

    // Check if an element is visible in the viewport
    isVisible(box) {
      const offset = box.getAttribute("data-wow-offset") || this.config.offset;
      const viewTop = window.pageYOffset;
      const viewBottom = viewTop + this.element.clientHeight - offset;

      const top = this.offsetTop(box);
      const bottom = top + box.clientHeight;

      return viewBottom >= top && bottom >= viewTop;
    }

    // Disable WOW.js on mobile if configured
    disabled() {
      return !this.config.mobile && this.util.isMobile(navigator.userAgent);
    }
  };
}).call(this);
